
/*************************************************************
	Практическое занятие №5. 
	"Старые" потоковые функции стандартной библиотеки
	Указатели на функции
	Структуры
*************************************************************/
#include <tchar.h>
#include <iostream>
#include <cstdio>
#include <cmath>
#include "other.h"


#define	  stop __asm nop

BOOK gBook;//Поля инициализируются 0 значениями

int _tmain()
{
	//Тема "Старые" потоковые функции стандартной библиотеки
	//Задание 1. С помощью функции scanf сформирйуте три коэффициента: A,B,C
	int A, B, C;
	printf("Enter coeff A B C ");
	scanf("%d %d %d", &A, &B, &C);


	//Задание 2. Выведите (красиво!) таблицу значений y=A*x*x + B*x + C
	//при изменении x в диапазоне -2 до +2 с шагом 0.5
	for(float x = -2; x < 2; x += 0.5)
		printf("%2.2f  %2.2f\n", A*x*x + B*x + C, x);


///////////////////////////////////////////////////////////////////
	//Тема Указатели на функции

	//Задание 1. Указатель на функцию. "Калькулятор".
	//Напишите функции:
	//1)Sum - принимает два значения double и возвращает сумму
	//этих значений
	//2)Sub- принимает два значения double и возвращает разность
	//этих значений
	//3)Mul - *
	//4)Div - /
	//5)а для возведения в степень можете использовать функцию стандартной библиотеки
	//		- pow(). Подсказка 1: прототип функции находится в <cmath>.
	//		Подсказка 2: стандартная библиотека предоставляет несколько перегруженных
	//		вариантов этой функции, а Вам потребуется сформировать указатель на 
	//		double pow(double, double);

	//Предоставьте пользователю	следующую возможность:
	//пока пользователь хочет пользоваться услугами Вашего калькулятора,
	//он может вводить два значения и знак операции
	//а Вы выводите результат. Результат получаете посредством вызова
	//соответствующей Вашей функции по указателю.
	//Предусмотрите возможность ввода непредусмотренного знака операции
	double a, b;
	char op = 0;
	double (*pFunc)(double, double) = 0;	
	while(op != 'q')
	{

		printf("Enter operand1 operand2 operation: ");
		scanf("%lf %lf %c", &a, &b, &op);

		switch(op)
		{
			case '+': pFunc = Sum;
				break;
			case '-': pFunc = Sub;
				break;
			case '*': pFunc = Mul;
				break;
			case '/': pFunc = Div;
				break;
			case '^': pFunc = pow;
				break;
			case 'q': continue; 
			default:
				printf("Wrong operation!\n");
				continue;
		}

		printf("Result is: %lf\n", pFunc(a, b));
	}
	stop
	//Задание 2. Указатель на функцию в качестве аргумента.
	//Дана заготовка функции сортировки любых объектов - Sort.
	//Функция принимает следующие параметры:
	//1) указатель на первый сортируемый элемент
	//2) количество сортируемых элементов
	//3) размер элемента в байтах
	//4) указатель на функцию перестановки элементов
	//5) указатель на функцию сравнения элементов

	//2a. Напишите функцию перестановки двух целых значений -
	// SwapInt, которая принимает два void указателя и 
	//меняет значения местами

	//Напишите функцию сравнения двух целых значений -
	// CmpInt, которая принимает два void указателя и
	//возвращает int результат сравнения: 
	//<0 - первый элемент меньше, чем второй
	//=0 - равны
	//>0 - первый элемент больше, чем второй
	{
		int nAr[]= {1,2,6,8,9,1,6};	//массив для сортировки

		//Печать исходного массива
		int nTotal = sizeof(nAr)/sizeof(nAr[0]);			//количество элементов в массиве 
		printf("Source array:\n");
		for(int i = 0; i < nTotal; i++)
			printf("%d\n", nAr[i]);


		//Вызов сортировки
		Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), SwapInt, CmpInt);

		//Печать результатов сортировки
		printf("Result array:\n");
		for(int i = 0; i < nTotal; i++)
			printf("%d\n", nAr[i]);
	}
	stop


	//Задание 2б. По аналогии с 8а создайте вспомогательные
	//функции - SwapDouble и CmpDouble и вызовите функцию Sort
	//для сортировки массива вещественных значений.
	{
		double nAr[]= {1.4, 2.4, 6, 8.6, 9.3, 1.1, 6.4};	//массив для сортировки

		//Печать исходного массива
		int nTotal = sizeof(nAr)/sizeof(nAr[0]);			//количество элементов в массиве 
		printf("Source array:\n");
		for(int i = 0; i < nTotal; i++)
			printf("%lf\n", nAr[i]);


		//Вызов сортировки
		Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(double), SwapDouble, CmpDouble);

		//Печать результатов сортировки
		printf("Result array:\n");
		for(int i = 0; i < nTotal; i++)
			printf("%lf\n", nAr[i]);
		stop
	}


	//Задание 2в*. По аналогии с 8а создайте вспомогательные
	//функции - SwapStr и CmpStr и вызовите функцию Sort 
	//для сортировки массива указателей на строки.
		{
			char* arStr[] = {"QQQ", "SDF", "ABC", "QWERTY"};

			//Печать исходного массива
			int nTotal = sizeof(arStr)/sizeof(arStr[0]);			//количество элементов в массиве 
			printf("Source array:\n");
			for(int i = 0; i < nTotal; i++)
				printf("%s\n", arStr[i]);


			//Вызов сортировки
			Sort(reinterpret_cast<char*>(&arStr[0]), nTotal, sizeof(char*), SwapStr, CmpStr);

			//Печать результатов сортировки
			printf("Result array:\n");
			for(int i = 0; i < nTotal; i++)
				printf("%s\n", arStr[i]);
			stop
	}


	//Задание 3. Массивы указателей на функцию.
	//Напишите несколько функций вида
	//const char* GetString1();
	//const char* GetString2();
	//		...., каждая из функций возвращает указатель на свою строку
	//(подумайте - какой адрес Вы имеете право возвращать из функции)
	

	//Объявите и проинициализируйте массив указателей на функции
	//GetString1,GetString2...
		const char* (*funcAr[])() = {GetString1, GetString2, GetString3};


	//Введите номер функции, которую Вы хотите вызвать:
	int n;
	printf("Enter function number(1-3): ");
	scanf("%d", &n);

	
    //Вызовите функцию 
	const char *str;
	if(n > 0 && n < 4)
		str = funcAr[n-1]();

	//Распечатайте результат
	printf("Function is: %d, result: %s\n", n, str);



//////////////////////////////////////////////////////////////////////////////////////
	//Тема. Структуры С.	
	//Задание 1. Объявите структуру BOOK, описывающую книгу
	//(автор, заглавие, год издания, цена, категория…).
	//Подумайте: какого типа могут быть поля структуры.
	//Подсказка: объявление структуры рекомендуется выносить
	//в заголовочный файл.
	//в other.h



	//Задание 2. Создайте разными способами (глобальный, локальный, статический,
	//динамический) экземпляры (объекты) типа BOOK (без инициализации).
	//Определите - сколько памяти отводит компилятор под каждый
	//такой объект. Как инициализируются (или не инициализируются) поля
	//структуры. Подумайте: от чего зависит объем выделяемой памяти?

	BOOK lBook;//Поля структуры не инициализируются (мусор)
	static BOOK sBook;//Поля инициализируются 0 значениями
	BOOK *dBook = new BOOK;//Поля структуры не инициализируются (мусор)

	int staticSz = sizeof(sBook);
	int globalSz = sizeof(gBook);
	int localSz = sizeof(lBook);
	int dynamicSz = sizeof(*dBook);
	//96байт
	stop


	//Задание 3. Заполните поля созданных объектов.
	//Замечание: если для хранения строки используется массив, необходимо
	//предусмотреть "защиту" от выхода за границы массива.
	{
		printf("Author= ");
		scanf("%19s", lBook.author);
		fflush(stdin);
		
		printf("Title= ");
		scanf("%19s", lBook.title);
		fflush(stdin);

		printf("Price= ");
		scanf("%lf", &lBook.price);
		printf("Year= ");
		scanf("%d", &lBook.year);
		printf("Category= ");
		scanf("%d", &lBook.category);
	}

	sBook = lBook;
	gBook = lBook;
	*dBook = lBook;



	//Задание 4. Напишите функцию, выводящую на экран реквизиты книги.
	//Подумайте: как эффективнее передавать экземпляр BOOK в функцию.
	//Для вывода на консоль используйте функцию стандартной библиотеки
	//printf
	printBook(lBook);
	printBook(sBook);
	printBook(gBook);
	printBook(*dBook);


	//Задание 5. Напишите функцию для формирования полей структуры.
	//Для ввода используйте функцию стандартной библиотеки scanf
	//Замечание: неплохо заложить в такую функцию возможность проверки
	//корректности введенного значения, например, год издания не может быть
	//меьше, чем... (год появления письменности), категорию ползователь
	//должен выбирать из существующих, цена не может быть отрицательной...
	readBook(lBook);
	printBook(lBook);

	delete dBook;
	return 0;
}//main

